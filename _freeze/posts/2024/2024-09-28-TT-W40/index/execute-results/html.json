{
  "hash": "15da0e1f111705139d1b5b1d3aa35f5a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualising positional moves in chess\"\ndescription: \"Analysis of #TidyTuesday's chess dataset\"\ndate: \"2024-09-28\"\nformat:\n  html:\n    page-layout: full\n    html-math-method: katex\ncategories:\n  - TidyTuesday\n  - data visualisation\nimage: ./chess_positions.png\neditor: source\neval: false\n---\n\n\n\n![](./chess_positions.png){.lightbox width=\"100%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n\nset.seed(321) # For reproducibility\n\n# Loading packages -------------------------------------------------------------\nlibrary(dplyr)            # Data manipulation\nlibrary(tidyr)            # Data pivoting\nlibrary(ggplot2)          # Visualisation\nlibrary(furrr)            # Parallel processing \nlibrary(kableExtra)       # Creating tables\nlibrary(rchess)           # Working with chess objects\nlibrary(ggeasy)           # Makes theming plots easier\n\n# Reading in data --------------------------------------------------------------\ndata <- tidytuesdayR::tt_load(2024, week = 40)\ndata <- data$chess\n```\n:::\n\n\n\nThis document analyzes a dataset of chess games from [Lichess](https://lichess.org/) provided by [#TidyTuesday](https://github.com/rfordatascience/tidytuesday). It contains over 20,000 games, including information such as player ratings, move sequences, and other metrics. The main focus of this analysis will be on the **specific moves played during each game**.\n\n# Chess Data\n\nThe dataset includes the move sequences made by each player, represented as a string of moves. Below is a preview of the first two rows of the dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>%\n  select(game_id, moves) %>%\n  mutate(game_id = seq(1:nrow(data))) %>%\n  rename(ID = game_id, Moves = moves) %>%\n  head(n = 2) %>%\n  kbl(align = \"c\") %>%\n  kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))\n```\n:::\n\n\n\nEach row displays the move sequence for a game, starting with White's move. For example, the **Slav Defense** (1. d4 d5 2. c4 c6) or the **Nimzowitsch Defense** (1. d4 Nc6 2. e4 e5). Chess moves are typically recorded using [Portable Game Notation (PGN)](https://www.chess.com/terms/chess-pgn), which makes it easy to replicate games.\n\n## PGN Conversion\n\nTo facilitate further analysis, we will convert the raw move strings into the PGN format, using a custom `convert_to_pgn()` function that I wrote.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert moves into PGN format ------------------------------------------------\nconvert_to_pgn <- function(moves, game_id) {\n  \n  # Split the moves string into a list of individual moves\n  move_list <- strsplit(moves, \" \")[[1]]\n  \n  # Initialize an empty string for the PGN format\n  pgn <- \"\"\n  \n  # Loop through the moves two at a time (each move is a pair: white and black)\n  for (i in seq(1, length(move_list), by = 2)) {\n    \n    move_number <- (i + 1) / 2 # Move number calculation\n    \n    # Add both white's and black's moves, if available\n    if (i < length(move_list)) {\n      pgn <- paste0(pgn, move_number, \". \", move_list[i], \" \", move_list[i+1], \" \")\n    } else {  # In case the game ends on white's move (no black move)\n      pgn <- paste0(pgn, move_number, \". \", move_list[i])\n    }\n  }\n\n  # Returning pgn string\n  return(pgn)\n}\n\n# Converting moves into pgn format\nchess_games <- data %>%\n  select(game_id, moves) %>%\n  mutate(\n    game_id = seq(1:nrow(data)),\n    moves = mapply(convert_to_pgn, moves, game_id))\n\n# Displaying converted dataset\nchess_games %>%\n  rename(ID = game_id, Moves = moves) %>%\n  head(n = 2) %>%\n  kbl(align = \"c\") %>%\n  kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))\n```\n:::\n\n\n\n## Extracting game history\n\nNow that the data is in PGN format, we can use the `history_detail()` from the `rhcess` package to extract the game history. However, because the dataset contains over 20,000 rows, processing every game sequentially would be time-consuming. To speed up this process, we will implement parallel processing using the `furrr` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to extract game history\nprocess_moves <- function(p) {\n  chss <- Chess$new()          # Initialize a new chess object\n  chss$load_pgn(p)             # Load the PGN notation into the chess object\n  chss$history_detail()        # Extract detailed history of the game\n}\n\nplan(multisession, workers = parallel::detectCores() - 1)\n\n# Parallel processing: Convert PGN format to game history\nchess_games <- chess_games %>%\n  mutate(data = future_map(moves, process_moves)) %>%\n  select(-moves) %>%\n  unnest(cols = c(data))\n\n# Displaying processed dataset\nchess_games %>%\n  rename(ID = game_id) %>%\n  kbl(align = \"c\") %>%\n  kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))\n```\n:::\n\n\n\n# Positional Movements\n\n## Creating a chess board\n\nFirst, we will create a chessboard visualization using `ggplot`. We can do this using the `.chessboard()` function, again from the `rchess` package. This function generates the grid and coordinates for each square which can piped into ggplot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a chess board -------------------------------------------------------\nboard <- rchess:::.chessboarddata() %>%\n  tibble() %>%\n  select(cell, col, row, x, y, cc)\n\n# Plotting\nboard %>%\n  ggplot() +\n  geom_tile(aes(x, y, fill = cc)) +\n  scale_fill_manual(values =  c(\"burlywood3\", \"burlywood4\")) + # Traditional board colours\n  theme_void() +\n  theme(axis.text = element_blank(), axis.ticks = element_blank()) +\n  easy_remove_legend()\n```\n:::\n\n\n\n## Adding board movements\n\nNext, we will join the chessboard data with the game data to calculate the origin and destination of each piece movement. This allows us to visualize the trajectories of pieces as they move across the board.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join board data with game data to get move origin and destination \nchess_games_paths <- chess_games %>%\n  left_join(board %>% rename(from = cell, x.from = x, y.from = y), by = \"from\") %>%\n  left_join(board %>%\n              rename(to = cell, x.to = x, y.to = y) %>% \n              select(-cc, -col, -row), # Exclude unnecessary columns\n            by = \"to\") %>%\n  mutate(x_gt_y = abs(x.to - x.from) > abs(y.to - y.from), # Check if x movement is greater than y\n         xy_sign = sign((x.to - x.from)*(y.to - y.from)) == 1, # Check if X and Y move in the same direction\n         x_gt_y_equal_xy_sign = x_gt_y == xy_sign) # Check if both conditions hold\n\n# Previewing\nchess_games_paths %>%\n  select(piece, from, to, x.from, y.from, x.to, y.to) %>%\n  head(n = 6) %>%\n  kbl(align = \"c\") %>%\n  kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))\n```\n:::\n\n\n\n## Getting positional movements (white)\n\nNext, we focus on the **major white pieces** and analyze their movements. Given the large dataset, we will randomly sample 25,000 moves to avoid overcrowded plots and improve readability.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Major white pieces\nwhite_pieces <- c(\n  \"a1 Rook\", \"b1 Knight\", \"c1 Bishop\", \"White Queen\", \n  \"White King\", \"f1 Bishop\", \"g1 Knight\", \"h1 Rook\")\n\n# Filter paths to only include major pieces\n# Using every move from the dataset produces a messy overcrowded plot\n# So instead we will sample 25000 random moves\nchess_games_paths_white <- chess_games_paths %>% \n  filter(piece %in% white_pieces) %>%\n  sample_n(25000)\n\n# Previewing\nchess_games_paths_white %>%\n  select(piece, from, to, x.from, y.from, x.to, y.to) %>%\n  head(n = 6) %>%\n  kbl(align = \"c\") %>%\n  kable_styling(\n    full_width = FALSE,\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))\n```\n:::\n\n\n\n## Plotting piece movements\n\nNow that we have filtered the moves for major white pieces, we can visualize their paths on the chessboard.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchess_games_paths_white %>%\n  ggplot() +\n  \n  # Adding board data\n  geom_tile(data = board, aes(x, y, fill = cc)) +\n  \n  # Adding piece movement\n  geom_curve(\n    data = paths_pieces %>% filter(x_gt_y_equal_xy_sign),\n    aes(x = x.from, y = y.from, xend = x.to, yend = y.to),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = 0.50, angle = -45, alpha = 0.02, color = \"white\", \n    linewidth = 1.02) +\n  geom_curve(\n    data = paths_pieces %>% filter(!x_gt_y_equal_xy_sign),\n    aes(x = x.from, y = y.from, xend = x.to, yend = y.to),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = -0.50, angle = 45, alpha = 0.02, color = \"white\", \n    linewidth = 1.02) +\n  \n  # Customizing\n  labs(title = \"Positional movements of major chess pieces\", x = \"\", y = \"\") +\n  scale_fill_manual(values =  c(\"burlywood3\", \"burlywood4\")) +\n  coord_equal() +\n  facet_wrap(~ factor(piece, c(white_pieces)), ncol = 4) +\n  theme_void() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 15, \n                              face = \"bold\", margin = margin(0, 0, 15, 0)),\n    strip.text = element_text(size = 9, face = \"bold\", margin = margin(0, 0, 2, 0)),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n  ) +\n  ggeasy::easy_remove_legend() +\n  ggeasy::easy_remove_gridlines()\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}